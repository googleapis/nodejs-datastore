"use strict";
/**
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pack = pack;
exports.packNTest = packNTest;
const execa = require("execa");
const Arborist = require("@npmcli/arborist");
const packlist = require("npm-packlist");
const path = require("path");
const tar = require("tar");
const promises_1 = require("fs/promises");
const tmp = require("tmp");
const rimraf_1 = require("rimraf");
function getSample(sample) {
    if (!sample.js && !sample.cjs && !sample.esm && !sample.mjs && !sample.ts) {
        throw new Error('code block not defined');
    }
    return sample.ts
        ? { code: String(sample.ts), filename: 'index.ts' }
        : sample.esm
            ? { code: String(sample.esm), filename: 'index.mjs' }
            : sample.mjs
                ? { code: String(sample.mjs), filename: 'index.mjs' }
                : sample.cjs
                    ? { code: String(sample.cjs), filename: 'index.cjs' }
                    : { code: String(sample.js), filename: 'index.js' };
}
function getExecFilename(sample) {
    const { filename } = getSample(sample);
    return filename === 'index.ts' ? 'index.js' : filename;
}
async function pack(packageDir, targetDir) {
    const packageTarball = path.join(targetDir, 'module-under-test.tgz');
    const arb = new Arborist({ path: packageDir });
    const tree = await arb.loadActual();
    const files = await packlist(tree);
    await tar.create({
        prefix: 'package/',
        cwd: packageDir,
        file: packageTarball,
        gzip: true,
    }, files);
    return packageTarball;
}
/**
 * `gts`'s `tsconfig.json`.
 */
const GTS_CONFIG_PATH = './node_modules/gts/tsconfig-google.json';
async function packNTest(options) {
    const moduleUnderTest = options.packageDir || process.cwd();
    const installDir = tmp.dirSync().name;
    try {
        const tarball = await pack(moduleUnderTest, installDir);
        await prepareTarget(tarball);
        const filename = getExecFilename(options.sample);
        await execa('node', [filename], { cwd: installDir });
    }
    catch (err) {
        console.error(err);
        throw err;
    }
    finally {
        await (0, rimraf_1.rimraf)(installDir);
    }
    return;
    async function prepareTarget(tarball) {
        // Generate a package.json.
        await execa('npm', ['init', '-y'], { cwd: installDir });
        const sample = options.sample;
        const tsconfigPath = options.tsconfigPath || GTS_CONFIG_PATH;
        const dependencies = sample.dependencies || [];
        const devDependencies = sample.devDependencies || [];
        if (sample.ts) {
            devDependencies.push('typescript');
            devDependencies.push('@types/node');
            if (tsconfigPath === GTS_CONFIG_PATH) {
                devDependencies.push('gts');
            }
        }
        // Add dependencies, including tarball, to package.json.
        // TODO: modify package.json rather than spawning npm.
        await execa('npm', ['install', '--prefer-offline', '--save', tarball].concat(dependencies), { cwd: installDir });
        await execa('npm', ['install', '--prefer-offline', '--save-dev'].concat(devDependencies), { cwd: installDir });
        // Populate test code.
        const { code, filename } = getSample(sample);
        await (0, promises_1.writeFile)(path.join(installDir, filename), code, 'utf-8');
        if (sample.ts) {
            const testConfig = {
                extends: tsconfigPath,
                files: ['index.ts'],
                compilerOptions: {
                    rootDir: '.',
                    resolveJsonModule: true,
                    allowSyntheticDefaultImports: true,
                },
            };
            // this is the config `tsc` will use for compilation locally.
            await (0, promises_1.writeFile)(path.join(installDir, 'tsconfig.json'), JSON.stringify(testConfig));
            await execa('npx', ['tsc'], { cwd: installDir });
        }
    }
}
//# sourceMappingURL=pack-n-test.js.map